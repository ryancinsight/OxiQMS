//! Strategy Pattern for Output Format Handling
//! 
//! This module implements the Strategy pattern for different output formats,
//! following SOLID principles for medical device quality management.
//! 
//! SOLID Principles Applied:
//! - Single Responsibility: Each strategy handles one specific output format
//! - Open/Closed: New output formats can be added without modifying existing code
//! - Liskov Substitution: All format strategies can be used interchangeably
//! - Interface Segregation: Focused interface for format-specific operations
//! - Dependency Inversion: High-level code depends on format strategy abstractions

use crate::prelude::*;
// KISS: Use explicit imports to avoid ValidationResult ambiguity
use super::super::interfaces::report_interfaces::{
    ValidationResult, ReportMetadata, OutputFormat
};
use super::super::template_method::base_report_generator::ReportFormatter;
use std::fmt::Write;

/// Strategy pattern interface for output format handling
/// Interface Segregation Principle: Focused interface for format operations
pub trait FormatStrategy {
    /// Get format-specific header
    fn get_header(&self, metadata: &ReportMetadata, title: &str) -> String;

    /// Get format-specific footer
    fn get_footer(&self, metadata: &ReportMetadata) -> String;

    /// Get format identifier
    fn format_name(&self) -> &'static str;

    /// Get file extension for this format
    fn file_extension(&self) -> &'static str;

    /// Get MIME type for this format
    fn mime_type(&self) -> &'static str;

    /// Validate format-specific content
    fn validate_content(&self, content: &str) -> QmsResult<ValidationResult>;
}

/// Markdown format strategy
/// Single Responsibility Principle: Handles only Markdown format operations
pub struct MarkdownFormatStrategy;

impl FormatStrategy for MarkdownFormatStrategy {
    fn get_header(&self, metadata: &ReportMetadata, title: &str) -> String {
        ReportFormatter::generate_header(metadata, title)
    }
    
    fn get_footer(&self, metadata: &ReportMetadata) -> String {
        ReportFormatter::generate_footer(metadata)
    }
    
    fn format_name(&self) -> &'static str {
        "Markdown"
    }
    
    fn file_extension(&self) -> &'static str {
        "md"
    }
    
    fn mime_type(&self) -> &'static str {
        "text/markdown"
    }
    
    fn validate_content(&self, content: &str) -> QmsResult<ValidationResult> {
        let mut errors = Vec::new();
        let mut warnings = Vec::new();
        
        // Basic markdown validation
        if content.is_empty() {
            errors.push("Content is empty".to_string());
        }
        
        // Check for basic markdown structure
        if !content.contains('#') {
            warnings.push("No headers found in markdown content".to_string());
        }
        
        // Check for very long lines (readability)
        for (line_num, line) in content.lines().enumerate() {
            if line.len() > 120 {
                warnings.push(format!("Line {} is very long ({} characters)", line_num + 1, line.len()));
            }
        }
        
        Ok(ValidationResult {
            is_valid: errors.is_empty(),
            errors,
            warnings,
        })
    }
}

/// CSV format strategy
/// Single Responsibility Principle: Handles only CSV format operations
pub struct CSVFormatStrategy;

impl FormatStrategy for CSVFormatStrategy {
    fn get_header(&self, metadata: &ReportMetadata, title: &str) -> String {
        format!(
            "# {}\n# Generated: {}\n# Generated By: {}\n# Project: {}\n",
            title,
            metadata.generated_at,
            metadata.generated_by,
            metadata.project_path
        )
    }
    
    fn get_footer(&self, metadata: &ReportMetadata) -> String {
        format!(
            "# Report generated automatically by QMS system\n# Generated: {}\n",
            metadata.generated_at
        )
    }
    
    fn format_name(&self) -> &'static str {
        "CSV"
    }
    
    fn file_extension(&self) -> &'static str {
        "csv"
    }
    
    fn mime_type(&self) -> &'static str {
        "text/csv"
    }
    
    fn validate_content(&self, content: &str) -> QmsResult<ValidationResult> {
        let mut errors = Vec::new();
        let mut warnings = Vec::new();

        if content.is_empty() {
            errors.push("CSV content is empty".to_string());
            return Ok(ValidationResult {
                is_valid: false,
                errors,
                warnings,
            });
        }
        
        let lines: Vec<&str> = content.lines().collect();
        
        // Check for header row
        if lines.is_empty() {
            errors.push("CSV has no header row".to_string());
        } else {
            let header_columns = lines[0].split(',').count();
            
            // Validate that all rows have the same number of columns
            for (line_num, line) in lines.iter().enumerate().skip(1) {
                if !line.starts_with('#') { // Skip comment lines
                    let columns = line.split(',').count();
                    if columns != header_columns {
                        errors.push(format!(
                            "Row {} has {} columns, expected {} columns",
                            line_num + 1,
                            columns,
                            header_columns
                        ));
                    }
                }
            }
            
            // Check for reasonable number of columns
            if header_columns > 50 {
                warnings.push(format!("CSV has many columns ({}), consider splitting into multiple reports", header_columns));
            }
        }
        
        Ok(ValidationResult {
            is_valid: errors.is_empty(),
            errors,
            warnings,
        })
    }
}

/// JSON format strategy
/// Single Responsibility Principle: Handles only JSON format operations
pub struct JSONFormatStrategy;

impl FormatStrategy for JSONFormatStrategy {
    fn get_header(&self, _metadata: &ReportMetadata, _title: &str) -> String {
        // JSON doesn't need separate headers - metadata is included in the structure
        String::new()
    }
    
    fn get_footer(&self, _metadata: &ReportMetadata) -> String {
        // JSON doesn't need separate footers
        String::new()
    }
    
    fn format_name(&self) -> &'static str {
        "JSON"
    }
    
    fn file_extension(&self) -> &'static str {
        "json"
    }
    
    fn mime_type(&self) -> &'static str {
        "application/json"
    }
    
    fn validate_content(&self, content: &str) -> QmsResult<ValidationResult> {
        let mut errors = Vec::new();
        let warnings = Vec::new();

        if content.is_empty() {
            errors.push("JSON content is empty".to_string());
            return Ok(ValidationResult {
                is_valid: false,
                errors,
                warnings,
            });
        }
        
        // Basic JSON structure validation
        let trimmed = content.trim();
        if !trimmed.starts_with('{') || !trimmed.ends_with('}') {
            errors.push("JSON content must start with '{' and end with '}'".to_string());
        }
        
        // Check for balanced braces (simple validation)
        let mut brace_count = 0;
        let mut in_string = false;
        let mut escaped = false;
        
        for ch in trimmed.chars() {
            if escaped {
                escaped = false;
                continue;
            }
            
            match ch {
                '\\' if in_string => escaped = true,
                '"' => in_string = !in_string,
                '{' if !in_string => brace_count += 1,
                '}' if !in_string => brace_count -= 1,
                _ => {}
            }
        }
        
        if brace_count != 0 {
            errors.push("Unbalanced braces in JSON content".to_string());
        }
        
        Ok(ValidationResult {
            is_valid: errors.is_empty(),
            errors,
            warnings,
        })
    }
}

/// HTML format strategy
/// Single Responsibility Principle: Handles only HTML format operations
pub struct HTMLFormatStrategy;

impl FormatStrategy for HTMLFormatStrategy {
    fn get_header(&self, _metadata: &ReportMetadata, _title: &str) -> String {
        // HTML header is included in the full document structure
        String::new()
    }
    
    fn get_footer(&self, _metadata: &ReportMetadata) -> String {
        // HTML footer is included in the full document structure
        String::new()
    }
    
    fn format_name(&self) -> &'static str {
        "HTML"
    }
    
    fn file_extension(&self) -> &'static str {
        "html"
    }
    
    fn mime_type(&self) -> &'static str {
        "text/html"
    }
    
    fn validate_content(&self, content: &str) -> QmsResult<ValidationResult> {
        let mut errors = Vec::new();
        let mut warnings = Vec::new();

        if content.is_empty() {
            errors.push("HTML content is empty".to_string());
            return Ok(ValidationResult {
                is_valid: false,
                errors,
                warnings,
            });
        }
        
        // Basic HTML structure validation
        let content_lower = content.to_lowercase();
        
        if !content_lower.contains("<!doctype html>") {
            warnings.push("Missing DOCTYPE declaration".to_string());
        }
        
        if !content_lower.contains("<html") {
            errors.push("Missing <html> tag".to_string());
        }
        
        if !content_lower.contains("<head>") {
            warnings.push("Missing <head> section".to_string());
        }
        
        if !content_lower.contains("<body>") {
            errors.push("Missing <body> tag".to_string());
        }
        
        // Check for balanced tags (simplified)
        let html_count = content_lower.matches("<html").count();
        let html_close_count = content_lower.matches("</html>").count();
        if html_count != html_close_count {
            errors.push("Unbalanced <html> tags".to_string());
        }
        
        let body_count = content_lower.matches("<body").count();
        let body_close_count = content_lower.matches("</body>").count();
        if body_count != body_close_count {
            errors.push("Unbalanced <body> tags".to_string());
        }
        
        Ok(ValidationResult {
            is_valid: errors.is_empty(),
            errors,
            warnings,
        })
    }
}

/// Factory for creating format strategies
/// Open/Closed Principle: New format strategies can be added without modifying this factory
/// Dependency Inversion Principle: Returns trait objects, not concrete types
pub struct FormatStrategyFactory;

impl FormatStrategyFactory {
    /// Create format strategy based on output format
    /// REFACTORED: Now uses OCP-compliant format registry
    /// Factory Method Pattern: Encapsulates strategy creation logic
    pub fn create_strategy(format: &OutputFormat) -> QmsResult<Box<dyn FormatStrategy>> {
        use crate::modules::report_generator::format_registry::get_format_registry;

        // Use the OCP-compliant format registry
        get_format_registry().create_strategy_from_output_format(format)
    }

    /// Create format strategy by name (OCP: extensible without modification)
    pub fn create_strategy_by_name(format_name: &str) -> QmsResult<Box<dyn FormatStrategy>> {
        use crate::modules::report_generator::format_registry::get_format_registry;

        get_format_registry().create_strategy(format_name)
    }
    
    /// Get all available format strategies (OCP: automatically includes new registered formats)
    pub fn available_formats() -> Vec<OutputFormat> {
        // For backward compatibility, return the enum variants
        // In a full OCP implementation, this would be dynamic based on registry
        vec![
            OutputFormat::Markdown,
            OutputFormat::CSV,
            OutputFormat::JSON,
            OutputFormat::HTML,
            OutputFormat::PDF,
        ]
    }

    /// Get all available formats as strings (OCP: dynamic based on registry)
    pub fn get_available_format_names() -> QmsResult<Vec<String>> {
        use crate::modules::report_generator::format_registry::get_format_registry;

        let formats = get_format_registry().get_registered_formats()?;
        Ok(formats.into_iter().map(|f| f.name).collect())
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_markdown_strategy() {
        let strategy = MarkdownFormatStrategy;
        assert_eq!(strategy.format_name(), "Markdown");
        assert_eq!(strategy.file_extension(), "md");
        assert_eq!(strategy.mime_type(), "text/markdown");
    }

    #[test]
    fn test_csv_strategy() {
        let strategy = CSVFormatStrategy;
        assert_eq!(strategy.format_name(), "CSV");
        assert_eq!(strategy.file_extension(), "csv");
        assert_eq!(strategy.mime_type(), "text/csv");
    }

    #[test]
    fn test_json_strategy() {
        let strategy = JSONFormatStrategy;
        assert_eq!(strategy.format_name(), "JSON");
        assert_eq!(strategy.file_extension(), "json");
        assert_eq!(strategy.mime_type(), "application/json");
    }

    #[test]
    fn test_html_strategy() {
        let strategy = HTMLFormatStrategy;
        assert_eq!(strategy.format_name(), "HTML");
        assert_eq!(strategy.file_extension(), "html");
        assert_eq!(strategy.mime_type(), "text/html");
    }

    #[test]
    fn test_format_strategy_factory() {
        let markdown_strategy = FormatStrategyFactory::create_strategy(&OutputFormat::Markdown).unwrap();
        assert_eq!(markdown_strategy.format_name(), "Markdown");
        
        let csv_strategy = FormatStrategyFactory::create_strategy(&OutputFormat::CSV).unwrap();
        assert_eq!(csv_strategy.format_name(), "CSV");
        
        let json_strategy = FormatStrategyFactory::create_strategy(&OutputFormat::JSON).unwrap();
        assert_eq!(json_strategy.format_name(), "JSON");
    }

    #[test]
    fn test_available_formats() {
        let formats = FormatStrategyFactory::available_formats();
        assert!(formats.contains(&OutputFormat::Markdown));
        assert!(formats.contains(&OutputFormat::CSV));
        assert!(formats.contains(&OutputFormat::JSON));
        assert!(formats.contains(&OutputFormat::HTML));
    }

    #[test]
    fn test_markdown_validation() {
        let strategy = MarkdownFormatStrategy;
        
        let valid_content = "# Title\n\nSome content here.";
        let result = strategy.validate_content(valid_content).unwrap();
        assert!(result.is_valid);
        
        let empty_content = "";
        let result = strategy.validate_content(empty_content).unwrap();
        assert!(!result.is_valid);
        assert_eq!(result.errors.len(), 1);
    }

    #[test]
    fn test_csv_validation() {
        let strategy = CSVFormatStrategy;
        
        let valid_csv = "Name,Age,City\nJohn,30,NYC\nJane,25,LA";
        let result = strategy.validate_content(valid_csv).unwrap();
        assert!(result.is_valid);
        
        let invalid_csv = "Name,Age,City\nJohn,30\nJane,25,LA,Extra";
        let result = strategy.validate_content(invalid_csv).unwrap();
        assert!(!result.is_valid);
        assert!(!result.errors.is_empty());
    }

    #[test]
    fn test_json_validation() {
        let strategy = JSONFormatStrategy;
        
        let valid_json = r#"{"name": "test", "value": 123}"#;
        let result = strategy.validate_content(valid_json).unwrap();
        assert!(result.is_valid);
        
        let invalid_json = r#"{"name": "test", "value": 123"#; // Missing closing brace
        let result = strategy.validate_content(invalid_json).unwrap();
        assert!(!result.is_valid);
    }

    #[test]
    fn test_html_validation() {
        let strategy = HTMLFormatStrategy;
        
        let valid_html = "<!DOCTYPE html><html><head></head><body><h1>Test</h1></body></html>";
        let result = strategy.validate_content(valid_html).unwrap();
        assert!(result.is_valid);
        
        let invalid_html = "<html><body><h1>Test</h1>"; // Missing closing tags
        let result = strategy.validate_content(invalid_html).unwrap();
        assert!(!result.is_valid);
    }
}
